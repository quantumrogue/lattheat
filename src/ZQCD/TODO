1) WRITE THE CODE
  |done! <---`ZQCD.jl`
  |done! <---  - Define `ZQCDParm{T}`
  |done! <---  - Define a constructor that initialize `ZQCDParm{T}` with coefficients from the paper
  |done! <---  - Define `ZQCDWorkspace{T}` 
  - Test consistency

`ZQCDAction.jl`
  - Write `zqcd_action` and `krnl_act!`
  - Test consistency

`ZQCDFields.jl`
  - Write `randomize` and `krnl_assign_SU2` (maybe simply reusable from ScalarFields.jl?)

`ZQCDForce.jl`
  - Write `force_zqcd` and `krnl_force_zqcd!`
  - Test consistency

`ZQCDHMC.jl`
  - Write `hamiltonian`
  - write `HMC!`
  - write `MD!`
  - test HMC and diagnostics

`ZQCDObs.jl`



1) TEST/PLAY WITH THE CODE AND ESTIMATE GPU MEMORY TIME/USAGE

2) REPRODUCE PAPER RESULTS




================== QUESTIONS =================
How does memory allocation works in kernel???

From `YMact.jl`:
  `gt1 = U[bu1,id2,ru1]`
  `S += tr(U[b,id1,r]*gt1 / (U[b,id2,r]*U[bu2,id1,ru2]))`
- why matrix multiplication is not inline? 
- matrix allocated every time? Isn't this wrong???


Why not using shared memory in blocks?
 `cache = @cuDynamicSharedMem(Int64, threadsPerBlock)`